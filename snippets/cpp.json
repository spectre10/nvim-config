{
    "fenwick": {
        "prefix": "fenwick",
        "body": [
            "// range update, point query",
            "class fenwick {",
            "    vector<int> tree;",
            "    int n;",
            "    // 1-based indexing",
            "public:",
            "    void init(vector<int>& arr) {",
            "        n = arr.size();",
            "        tree.assign(n+1, 0);",
            "        foi(1,n+1) update(i, arr[i-1]);",
            "    }",
            "    void init(int x) {",
            "        n = x;",
            "        tree.assign(n+1, 0);",
            "    }",
            "    int sum(int i) // returns value at an index",
            "    { // time comp O(logn)",
            "        int ans = 0;",
            "        for (; i > 0; i -= (i & (-i))) {",
            "            ans += tree[i];",
            "        }",
            "        return ans;",
            "    }",
            "    void update(int i, int x) // adds x at an index",
            "    {",
            "        for (; i <= n; i += (i & (-i))) {",
            "            tree[i] += x;",
            "        }",
            "    }",
            "    void range_update(int l, int r, int x) { // adds x to indices l, l+1,..., r",
            "        update(l, x), update(r+1, -x);",
            "    }",
            "};"
        ],
        "description": "Fenwick Tree: range update, point query"
    },
    "nck": {
        "prefix": "nck",
        "body": [
            "vector<int> fact(300000);",
            "void pre()",
            "{",
            "    fact[0] = 1;",
            "    fact[1] = 1;",
            "    foi(2, 300000)",
            "    {",
            "        fact[i] = (fact[i - 1] * i) % mod;",
            "    }",
            "}",
            "",
            "int powmod(int a, int b, int x)",
            "{",
            "    a %= x;",
            "    if (a == 0)",
            "        return 0;",
            "    int product = 1;",
            "    while (b > 0) {",
            "        if (b & 1) { // you can also use b % 2 == 1",
            "            product *= a;",
            "            product %= x;",
            "            --b;",
            "        }",
            "        a *= a;",
            "        a %= x;",
            "        b /= 2; // you can also use b >> 1",
            "    }",
            "    return product;",
            "}",
            "int inv(int a, int x)",
            "{",
            "    return powmod(a, x - 2, x);",
            "}",
            "int nCk(int n, int k, int x)",
            "{",
            "    return ((fact[n] * inv(fact[k], p) % x) * inv(fact[n - k], x)) % x;",
            "}"
        ],
        "description": "nCk"
    },
    "powmod": {
        "prefix": "powmod",
        "body": [
            "int powmod(int a, int b, int x)",
            "{",
            "    a %= x;",
            "    if (a == 0)",
            "        return 0;",
            "    int product = 1;",
            "    while (b > 0) {",
            "        if (b & 1) { // you can also use b % 2 == 1",
            "            product *= a;",
            "            product %= x;",
            "            --b;",
            "        }",
            "        a *= a;",
            "        a %= x;",
            "        b /= 2; // you can also use b >> 1",
            "    }",
            "    return product;",
            "}"
        ],
        "description": "power with modulo"
    },
    "inverse": {
        "prefix": "inverse",
        "body": [
            "int powmod(int a, int b, int x)",
            "{",
            "    a %= x;",
            "    if (a == 0)",
            "        return 0;",
            "    int product = 1;",
            "    while (b > 0) {",
            "        if (b & 1) { // you can also use b % 2 == 1",
            "            product *= a;",
            "            product %= x;",
            "            --b;",
            "        }",
            "        a *= a;",
            "        a %= x;",
            "        b /= 2; // you can also use b >> 1",
            "    }",
            "    return product;",
            "}",
            "",
            "int inv(int a, int x)",
            "{",
            "    return powmod(a, x - 2, x);",
            "}"
        ],
        "description": "find inverse of a big number"
    },
    "factorsieve": {
        "prefix": "factorsieve",
        "body": [
            "// ",
            "// CALL sieve() IN MAIN",
            "// ",
            "#define MAXN 10000001",
            "// stores smallest prime factor for every number",
            "int spf[MAXN];",
            "",
            "// Calculating SPF (Smallest Prime Factor) for every",
            "// number till MAXN.",
            "// Time Complexity : O(nloglogn)",
            "void sieve()",
            "{",
            "    spf[1] = 1;",
            "    for (int i = 2; i < MAXN; i++)",
            "        spf[i] = i;",
            "    for (int i = 4; i < MAXN; i += 2)",
            "        spf[i] = 2;",
            "    for (int i = 3; i < MAXN; i++) {",
            "        if (spf[i] == i) {",
            "            for (int j = i * i; j < MAXN; j += i)",
            "                if (spf[j] == j)",
            "                    spf[j] = i;",
            "        }",
            "    }",
            "}",
            "set<int> getFactorization(int x)",
            "{ //time complexity of this function log(x)",
            "    set<int> ret;",
            "    while (x != 1) {",
            "        ret.insert(spf[x]);",
            "        x = x / spf[x];",
            "    }",
            "    return ret;",
            "}"
        ],
        "description": "prime factors using sieve"
    },
    "spf": {
        "prefix": "spf",
        "body": [
            "// ",
            "// CALL sieve() IN MAIN",
            "// ",
            "#define MAXN 10000001",
            "// stores smallest prime factor for every number",
            "int spf[MAXN];",
            "",
            "// Calculating SPF (Smallest Prime Factor) for every",
            "// number till MAXN.",
            "// Time Complexity : O(nloglogn)",
            "void sieve()",
            "{",
            "    spf[1] = 1;",
            "    for (int i = 2; i < MAXN; i++)",
            "        spf[i] = i;",
            "    for (int i = 4; i < MAXN; i += 2)",
            "        spf[i] = 2;",
            "    for (int i = 3; i < MAXN; i++) {",
            "        if (spf[i] == i) {",
            "            for (int j = i * i; j < MAXN; j += i)",
            "                if (spf[j] == j)",
            "                    spf[j] = i;",
            "        }",
            "    }",
            "}"
        ],
        "description": "smallest prime factor using sieve"
    },
    "dsu": {
        "prefix": "dsu",
        "body": [
            "class dsu {",
            "    vector<int> arr;",
            "",
            "public:",
            "    dsu(int n)",
            "    {",
            "        arr = vector<int>(n + 1, -1);",
            "    }",
            "    int find(int x)",
            "    {",
            "        if (arr[x] < 0)",
            "            return x;",
            "        return find(arr[x]);",
            "    }",
            "    void uni(int a, int b)",
            "    {",
            "        int x = find(a);",
            "        int y = find(b);",
            "        if (x == y) {",
            "            return;",
            "        }",
            "        arr[x] += arr[y];",
            "        arr[y] = x;",
            "    }",
            "    int getparents()",
            "    {",
            "        int ans = 0;",
            "        for (int i = 1; i < arr.size(); i++) {",
            "            if (arr[i] < 0)",
            "                ans++;",
            "        }",
            "        return ans;",
            "    }",
            "};"
        ],
        "description": "Disjoint set union for cycles"
    }
}
